(* ::Package:: *)

(* Autogenerated Package *)

BeginPackage["H5Core`"];


(* ::Subsubsection::Closed:: *)
(*Dirs and things*)



$H5Directory::usage="dooooooop";
H5PackageFile::usage="doooooooooooooooop";
$H5CalculationMode::";____;";


(* ::Subsubsection::Closed:: *)
(*ReloadDVR*)



ReloadDVRPackage::usage="";


(* ::Subsubsection::Closed:: *)
(*Core Data*)



CompiledSAPot::usage="";
H5PointwiseInterpCut::usage="";
H5VectorizedInterpCut::usage="";
h5PotCut::usage="";
h5PotCutVec::usage="";


(* ::Subsubsubsection::Closed:: *)
(* Base Geom*)



$H5PotentialRegion::usage="";


H5FullInterpPot::usage="";
H5FullPot::usage="";
H5FullVecPot::usage="";


H5OptDistances::usage="";


$H5DipoleSurfaceQuantityArray::usage="";
$H5DipoleSurfaceInterps::usage="";
$H5DipoleSurfaceVec::usage="";


(* ::Subsubsubsection::Closed:: *)
(*Parallel Geom*)



$H5OldInterpPot::usage="";
$H5OldPot::usage="";
$H5OldVecPot::usage="";


$H5ParallelFullInterpPot::usage="";
$H5ParallelFullPot::usage="";
$H5ParallelFullVecPot::usage="";


$H5ParallelDipoleSurfaceQuantityArray::usage="";
$H5ParallelDipoleSurfaceInterps::usage="";
$H5ParallelDipoleSurfaceVec::usage="";


(* ::Subsubsection::Closed:: *)
(*Potentials*)



outerH2Pot::usage="";
sharedHPot::usage="";
h2SinglePot::usage="";
h2OldSinglePot::usage="";
h2ParallelSinglePot::usage="";
h2Pot::usage="";


(* ::Subsubsection::Closed:: *)
(*DVRs*)



$H5DVR::usage="";
$H2DVR::usage="";
$H2SingleDVR::usage="";
$H54DDVR::usage="";


$D5DVR::usage="";
$D2DVR::usage="";
$D2SingleDVR::usage="";


(* ::Subsubsection::Closed:: *)
(*Plots*)



ListPlot5D::usage="";
ListDensityPlot5D::usage="";
H54DPlot::usage="";
H54DDensityPlot::usage="";


(* ::Subsubsection::Closed:: *)
(*Misc*)



$H2StateAssignments::usage="";


Begin["`Private`"];


<<ChemTools`DVR`


$H5PotentialRegion=
  {
    {0.15, 2.00},
    {0.15, 2.00},
    {0.45, 4.00},
    {0.45, 4.00}
    };


If[!ValueQ[$H5CalculationMode], 
  $H5CalculationMode = "Minimal"
  ]; (*choices are "CoreGrid" / "Extrapolated" / "Minimal"*)


(* ::Subsection:: *)
(*Directories*)



$H5Directory = 
  Nest[DirectoryName, $InputFileName, 2];


H5PackageFile[path__]:=
  FileNameJoin@Flatten@{$H5Directory, path}


(* ::Subsection:: *)
(*ReloadDVRPackage*)



ReloadDVRPackage[]:=(
  ChemTools["Get", "DVR/Package/Object"];
  ChemTools["Get", "DVR/Package/Grid"];
  ChemTools["Get", "DVR/Package/KineticEnergy"];
  ChemTools["Get", "DVR/Package/PotentialEnergy"];
  ChemTools["Get", "DVR/Package/PotentialOptimization"];
  ChemTools["Get", "DVR/Package/Wavefunctions"];
  ChemTools["Get", "DVR/Package/Plots"];
  )


(* ::Subsection:: *)
(*Compiled SA Potential*)



compiledSAPot[potInterp_]:=
  With[{dom=potInterp[[1]]},
    Compile[{{sa,_Real,1}},
      With[
        {
          R1=1/Sqrt[2](sa[[2]]+sa[[1]]),
          R2=1/Sqrt[2](sa[[2]]-sa[[1]])
          },
        If[dom[[1,1]]<=R2<=dom[[1,2]]&&
          dom[[2,1]]<=R1<=dom[[2,2]],
          potInterp[R1, R2],
          10^9
          ]
        ],
      RuntimeOptions->{
        "EvaluateSymbolically"->False,
        "WarningMessages"->False
        }
      ]
    ];


CompiledSAPot=compiledSAPot


(* ::Subsection:: *)
(*Domains*)



domainSpecs={Repeated[{_, _}, {4}]}|"Extrapolated"|"CoreGrid"|"Minimal"|Automatic


getDomain[interp_, domain_]:=
  Replace[
    Replace[domain, Automatic:>$H5CalculationMode],
    {
      "Extrapolated":>$H5PotentialRegion,
      "Minimal":>
        MapThread[
          {Max@{#[[1]], #2[[1]]}, Min@{#[[2]], #2[[2]]}}&,
          {
            interp[[1]],
            $H5PotentialRegion
            }
          ],
      "CoreGrid":>interp[[1]]
      }
    ]


(* ::Subsection:: *)
(*Interpolation Cuts*)



(* ::Subsubsection::Closed:: *)
(*Pointwise*)



H5PointwiseInterpCut//Clear
H5PointwiseInterpCut[
  {HA_, HS_, h2r1_, h2r2_}, 
  interp_, 
  domain:domainSpecs:Automatic,
  def:_?NumericQ:10.^9, 
  min:_?NumericQ:0.
  ]:=
With[
  {
    potInterp=interp,
    dom=getDomain[interp, domain]
    },
  Block[{asr1r2},
    Compile@@
    With[
      {
        r1Min=dom[[1,1]], r1Max=dom[[1,2]],
        r2Min=dom[[2,1]], r2Max=dom[[2,2]],
        R1Min=dom[[3,1]], R1Max=dom[[3,2]],
        R2Min=dom[[4,1]], R2Max=dom[[4,2]],
        varBlock=
        Quiet@
        {
          "R1"->
          Switch[
            {HA, HS},
            {Automatic, Automatic},
            1/Sqrt[2.](asr1r2[[2]]+asr1r2[[1]]),
            {Automatic, _},
            1/Sqrt[2.](HS+asr1r2[[1]]),
            {_, Automatic},
            1/Sqrt[2.](asr1r2[[1]]+HA),
            {_, _},
            1/Sqrt[2.](HA+HS)
            ],
          "R2"->
          Switch[
            {HA, HS},
            {Automatic, Automatic},
            1/Sqrt[2.](asr1r2[[2]]-asr1r2[[1]]),
            {Automatic, _},
            1/Sqrt[2.](HS-asr1r2[[1]]),
            {_, Automatic},
            1/Sqrt[2.](asr1r2[[1]]-HA),
            {_, _},
            1/Sqrt[2.](HS-HA)
            ],
          "r1"->
          If[h2r1===Automatic,
            asr1r2[[Count[{HA, HS}, Automatic]+1]],
            h2r1
            ],
          "r2"->
          If[h2r2===Automatic,
            asr1r2[[Count[{HA, HS, h2r1}, Automatic]+1]],
            h2r2
            ]
          }
        },
      With[
        {
          test=
          With[{tests={r1Min<="r1"<=r1Max,r2Min<="r2"<=r2Max,
              R1Min<="R1"<=R1Max,R2Min<="R2"<=R2Max}/.varBlock},
            If[MemberQ[tests, False&],
              False,
              And@@DeleteCases[tests, True]
              ]
            ]
          },
        Hold[
          {{asr1r2,_Real,1}},
          With[
            {
              R1="R1",
              R2="R2",
              r1="r1",
              r2="r2"
              },
            Module[{default=def, mininmum=min},
              If[test,
                potInterp[r1, r2, R1, R2]-mininmum,
                default
                ]
              ]
            ],
          RuntimeOptions->{
            "EvaluateSymbolically"->False,
            "WarningMessages"->False
            },
          RuntimeAttributes->{Listable}
          ]/.varBlock
        ]
      ]
    ]
  ];


h5PotCut[{HA_, HS_, h2r1_, h2r2_}, min_:0.]:=
  H5PointwiseInterpCut[
    {HA, HS, h2r1, h2r2},
    H5FullInterpPot,
    10.^9,
    min
    ]


(* ::Subsubsection::Closed:: *)
(*Vectorized*)



(*RotationTransform[-\[Pi]/4]@{a, s}*)


H5VectorizedInterpCut//Clear
H5VectorizedInterpCut[{HA_, HS_, h2r1_, h2r2_}, 
  interp_, 
  domain:domainSpecs:Automatic,
  def:_?NumericQ:10.^9, 
  min:_?NumericQ:0.
  ]:=
With[
  {
    potInterp=interp,
    dom=getDomain[interp, domain]
    },
  Block[{asr1r2, pt},
    (* Protect the variables that will be fed in*)
    With[
      {
        (* Decrease function size *)
        r1Min=dom[[1,1]], r1Max=dom[[1,2]],
        r2Min=dom[[2,1]], r2Max=dom[[2,2]],
        R1Min=dom[[3,1]], R1Max=dom[[3,2]],
        R2Min=dom[[4,1]], R2Max=dom[[4,2]]
        },
      Module[
        {
          getPot,
          varBlock,
          varBlock2
          },
        varBlock=
        Quiet@
        {(* flexible symbolic form for Compile vars *)
          "R1"->
          Switch[
            {HA, HS},
            {Automatic, Automatic},
            1/Sqrt[2.](asr1r2[[2]]+asr1r2[[1]]),
            {Automatic, _},
            1/Sqrt[2.](HS+asr1r2[[1]]),
            {_, Automatic},
            1/Sqrt[2.](asr1r2[[1]]+HA),
            {_, _},
            1/Sqrt[2.](HA+HS)
            ],
          "R2"->
          Switch[
            {HA, HS},
            {Automatic, Automatic},
            1/Sqrt[2.](asr1r2[[2]]-asr1r2[[1]]),
            {Automatic, _},
            1/Sqrt[2.](HS-asr1r2[[1]]),
            {_, Automatic},
            1/Sqrt[2.](asr1r2[[1]]-HA),
            {_, _},
            1/Sqrt[2.](HS-HA)
            ],
          "r1"->
          If[h2r1===Automatic,
            asr1r2[[Count[{HA, HS}, Automatic]+1]],
            h2r1
            ],
          "r2"->
          If[h2r2===Automatic,
            asr1r2[[Count[{HA, HS, h2r1}, Automatic]+1]],
            h2r2
            ],
          "Function"->Function
          };
        (* flexible symbolic form for Compile vars *)
        getPot[pts_]:=Apply[potInterp, pts];
        (* bounds checking for test *)
        With[
          {
            domo=
              {{r1Min, r1Max},{r2Min, r2Max},
                {R1Min,R1Max},{R2Min,R2Max}},
            testos=
            {r1Min<=pt[[1]]<=r1Max,r2Min<=pt[[2]]<=r2Max,
              R1Min<=pt[[3]]<=R1Max,R2Min<=pt[[4]]<=R2Max}//Quiet,
            test=
            With[{tests=
                {r1Min<=pt[[1]]<=r1Max,r2Min<=pt[[2]]<=r2Max,
                  R1Min<=pt[[3]]<=R1Max,R2Min<=pt[[4]]<=R2Max}//Quiet
                },
              If[MemberQ[tests, False&],
                False,
                And@@
                DeleteCases[
                  tests, 
                  True
                  ]
                ]
              ]
            },
          Compile@@
          ReplaceAll[
            Hold[(* True Compile body but with Hold for code injection *)
              {{gps,_Real,2}},
              Module[
                {
                  pts=
                  "Function"[
                    asr1r2,
                    {
                      "r1",
                      "r2",
                      "R1",
                      "R2"
                      }
                    ]/@gps,
                  ongrid=Table[0, {i, Length@gps}],
                  intres,
                  midpt=Mean/@dom,
                  interpvals,
                  interpcounter,
                  interppts,
                  i=1,
                  barrier=def,
                  minimum=min
                  },
                interppts=Table[midpt, {i, Length@pts}];
                (* Find points in domain *)
                interpcounter=0;
                Do[
                  If[test,
                    ongrid[[i]]=1;
                    interppts[[++interpcounter]]=pts[[i]](*,
										Echo@{pt, testos, domo}*)
                    ];
                  i++,
                  {pt, pts}
                  ];
                (* Apply InterpolatingFunction only once (one MainEval call) *)
                If[interpcounter>0,
                  intres=interppts[[;;interpcounter]];
                  interpvals=getPot[Transpose@intres]-minimum;
                  (* Pick points that are in domain *)
                  interpcounter=0;
                  Map[
                    If[#==1, interpvals[[++interpcounter]], barrier]&,
                    ongrid
                    ],
                  Table[barrier, {i, Length@gps}]
                  ]
                ],
              {{getPot[_], _Real, 1}},
              RuntimeOptions->{
                "EvaluateSymbolically"->False,
                "WarningMessages"->False
                }
              ],
            Quiet@varBlock
            ]
          ]
        ]
      ]
    ]
  ];


h5PotCutVec[{HA_, HS_, h2r1_, h2r2_}, min_:0.]:=
  H5VectorizedInterpCut[{HA, HS, h2r1, h2r2}, H5FullInterpPot, 10.^9, min]


(* ::Subsection:: *)
(*Full Potential*)



(* ::Subsubsection::Closed:: *)
(*setPotQA*)



(* ::Subsubsubsection::Closed:: *)
(*Bowtie*)



setPotQA[file_]:=
  If[Length@OwnValues@H5FullPotQA==0,
    H5FullPotQA:=
      H5FullPotQA=
        Import[
          file,
          {"GaussianLog", "ScanQuantityArray"}
          ][[2]]
    ]


setPotQARaw[file_]:=
  H5FullPotQARaw:=
    H5FullPotQARaw=
      Import[file]


(* ::Subsubsubsection::Closed:: *)
(*Parallel*)



setPotQAParallel[file_]:=
  If[Length@OwnValues@$H5ParallelFullPotQA==0,
    $H5ParallelFullPotQA:=
      $H5ParallelFullPotQA=
        Import[
          file,
          {"GaussianLog", "ScanQuantityArray"}
          ][[2]]
    ]


setPotQAParallelRaw[file_]:=
  $H5ParallelFullPotQARaw:=
    $H5ParallelFullPotQARaw=
      Import[file]


(* ::Subsubsubsection::Closed:: *)
(*Old*)



setPotQAOld[file_]:=
  If[Length@OwnValues@$H5OldPotQA==0,
    $H5OldPotQA:=
      $H5OldPotQA=
        Import[
          file,
          {"GaussianLog", "ScanQuantityArray"}
          ][[2]]
    ]


setPotQAOldRaw[file_]:=
  $H5OldPotQARaw:=
    $H5OldPotQARaw=
      Import[file]


(* ::Subsubsection::Closed:: *)
(*QuantityArray*)



(* ::Subsubsubsection::Closed:: *)
(*Bowtie*)



(*setPotQA@
	H5PackageFile["scans", "outer_H2_scan.log"];
setPotQA@
	H5PackageFile["scans", "h5_4D_H_center_scan.log"];
setPotQARaw@
	H5PackageFile["inputs", "h5_4D_H_center_scan_pot_QA.mx"];*)


setPotQARaw@
  H5PackageFile["inputs", "potential.mx"];


getSymmetrizedPotentialSurface[]:=
  Module[
    {qa, pvs, lhPVs, eqPVs},
    qa=H5FullPotQARaw;
    pvs=QuantityMagnitude@qa;
    lhPVs=Select[pvs, #[[3]]<#[[4]]&];
    eqPVs=Select[pvs, #[[3]]==#[[4]]&];
    pvs=
    Join[
      lhPVs,
      eqPVs,
      lhPVs[[-1;;1;;-1, {1, 2, 4, 3, 5}]]
      ];
    QuantityArray[pvs,QuantityUnit[qa][[1]]]
    ]


(*H5FullPotQA:=
H5FullPotQA=getSymmetrizedPotentialSurface[]*)


H5FullPotQA:=
H5FullPotQA=H5FullPotQARaw


(* ::Subsubsubsection::Closed:: *)
(*Parallel*)



setPotQAParallelRaw@
  H5PackageFile["inputs", "potential_parallel.mx"];


(* ::Subsubsubsection::Closed:: *)
(*Old*)



setPotQAOldRaw@
  H5PackageFile["inputs", "potential_old.mx"];


(* ::Subsubsection::Closed:: *)
(*Interpolation*)



(* ::Subsubsubsection::Closed:: *)
(*Bowtie*)



H5FullInterpPot:=
  H5FullInterpPot=
    With[{arr=QuantityMagnitude@H5FullPotQA},
      Interpolation[
        Transpose[{#[[All, ;;-2]], #[[All, -1]]}]&@With[{tr=Transpose[arr]},
          Transpose@
            ReplacePart[tr,
              -1->(tr[[-1]]-Min[tr[[-1]]])
              ]
          ],
        {
          "ExtrapolationHandler"->{(*Automatic*)(10.^9&), "WarningMessage"->False}
          }
        ]
      ];


(* ::Subsubsubsection::Closed:: *)
(*Parallel*)



$H5ParallelFullInterpPot:=
  $H5ParallelFullInterpPot=
    With[{arr=QuantityMagnitude@$H5ParallelFullPotQARaw},
      Interpolation[
        Transpose[{#[[All, ;;-2]], #[[All, -1]]}]&@With[{tr=Transpose[arr]},
          Transpose@
            ReplacePart[tr,
              -1->(tr[[-1]]-Min[tr[[-1]]])
              ]
          ],
        {
          "ExtrapolationHandler"->{(10.^9&), "WarningMessage"->False}
          }
        ]
      ];


(* ::Subsubsubsection::Closed:: *)
(*Old*)



$H5OldInterpPot:=
  $H5OldInterpPot=
    With[{arr=QuantityMagnitude@$H5OldPotQARaw},
      Interpolation[
        Transpose[{#[[All, ;;-2]], #[[All, -1]]}]&@With[{tr=Transpose[arr]},
          Transpose@
            ReplacePart[tr,
              -1->(tr[[-1]]-Min[tr[[-1]]])
              ]
          ],
        {
          "ExtrapolationHandler"->{(10.^9&), "WarningMessage"->False}
          }
        ]
      ];


(* ::Subsubsection::Closed:: *)
(*CompiledForm*)



(* ::Subsubsubsection::Closed:: *)
(*Pointwise*)



(* ::Subsubsubsubsection::Closed:: *)
(*Bowtie*)



H5FullPot:=
  H5FullPot=
    With[
      {
        potInterp=H5FullInterpPot,
        dom=$H5PotentialRegion
        },
      H5PointwiseInterpCut[
        {Automatic, Automatic, Automatic, Automatic},
        potInterp,
        dom,
        10.^9
        ]
      ];


(* ::Subsubsubsubsection::Closed:: *)
(*Parallel*)



$H5ParallelFullPot:=
  $H5ParallelFullPot=
    With[
      {
        potInterp=$H5ParallelFullInterpPot,
        dom=$H5PotentialRegion
        },
      H5PointwiseInterpCut[
        {Automatic, Automatic, Automatic, Automatic},
        potInterp,
        dom,
        10.^9
        ]
      ];


(* ::Subsubsubsubsection::Closed:: *)
(*Old*)



$H5OldPot:=
  $H5OldPot=
    With[
      {
        potInterp=$H5OldInterpPot,
        dom=$H5PotentialRegion
        },
      H5PointwiseInterpCut[
        {Automatic, Automatic, Automatic, Automatic},
        potInterp,
        dom,
        10.^9
        ]
      ];


(* ::Subsubsubsection::Closed:: *)
(*Vectorized*)



(* ::Subsubsubsubsection::Closed:: *)
(*Bowtie*)



H5FullVecPot:=
  H5FullVecPot=
    With[
      {
        potInterp=H5FullInterpPot,
        dom=$H5PotentialRegion
        },
      H5VectorizedInterpCut[
        {Automatic, Automatic, Automatic, Automatic},
        potInterp,
        dom,
        10.^9
        ]
      ]


(* ::Subsubsubsubsection::Closed:: *)
(*Parallel*)



$H5ParallelFullVecPot:=
  $H5ParallelFullVecPot=
    With[
      {
        potInterp=$H5ParallelFullInterpPot,
        dom=$H5PotentialRegion
        },
      H5VectorizedInterpCut[
        {Automatic, Automatic, Automatic, Automatic},
        potInterp,
        dom,
        10.^9
        ]
      ]


(* ::Subsubsubsubsection::Closed:: *)
(*Old*)



$H5OldVecPot:=
  $H5OldVecPot=
    With[
      {
        potInterp=$H5OldInterpPot,
        dom=$H5PotentialRegion
        },
      H5VectorizedInterpCut[
        {Automatic, Automatic, Automatic, Automatic},
        potInterp,
        dom,
        10.^9
        ]
      ];


(* ::Subsection:: *)
(*Optimized H5 Structure*)



(* ::Subsubsection::Closed:: *)
(*H5OptDistances*)



H5OptDistances:=
  H5OptDistances=
    Import[
      H5PackageFile["scans", "h5_opt_structure.gjf"],
      "GaussianJob"
      ]["System", "Variables"]//Map[Apply@Rule]


(* ::Subsection:: *)
(*Dipole Surface*)



(* ::Subsubsection::Closed:: *)
(*Dipole QA*)



(* ::Subsubsubsection::Closed:: *)
(*Historical Interest*)



(*$H5DipoleSurfaceRawQuantityArray:=
	$H5DipoleSurfaceRawQuantityArray=
		Import[
			H5PackageFile["scans", "outer_H2_scan.log"],
			{"GaussianLog"},
			"ImportedElements"\[Rule]"ScanDipoleSurface"
			];*)


(*$H5DipoleSurfaceRawQuantityArray:=
	$H5DipoleSurfaceRawQuantityArray=
		Import[
			H5PackageFile["scans", "h5_4D_H_center_scan.log"],
			{"GaussianLog"},
			"ImportedElements"\[Rule]"ScanDipoleSurface"
			];*)


(*$H5DipoleSurfaceRawQuantityArray:=
$H5DipoleSurfaceRawQuantityArray=Import["~/Documents/UW/Research/H5+/inputs/h5_dip_QA.mx"];*)


(*$H5DipoleSurfaceRawQuantityArray:=
	$H5DipoleSurfaceRawQuantityArray=
		Import@H5PackageFile["inputs", "h5_dip_QA_new.mx"];*)


(*getSymmetrizedDipoleMoments[]:=
Module[
{qa, dvs, lhDVs, eqDVs},
qa=$H5DipoleSurfaceRawQuantityArray[[2]];
dvs=QuantityMagnitude@qa;
lhDVs=Select[dvs, #[[3]]<#[[4]]&];
eqDVs=Select[dvs, #[[3]]==#[[4]]&];
dvs=
Join[
lhDVs,
eqDVs,
ConstantArray[
{1, 1, 1, 1, -1, -1, -1},
Length@lhDVs
]*lhDVs[[-1;;1;;-1, {1, 2, 4, 3, 5, 6, 7}]]
];
QuantityArray[dvs,QuantityUnit[qa][[1]]]
]*)


(*$H5DipoleSurfaceQuantityArray:=
$H5DipoleSurfaceQuantityArray=$H5DipoleSurfaceRawQuantityArray;*)
 (*getSymmetrizedDipoleMoments[]*)


(*getRecenteredDipoleMoments[]:=
Module[
{weirdRCoeff, dipVecs, qa},
qa=$H5DipoleSurfaceRawQuantityArray;
weirdRCoeff=
QuantityMagnitude[
UnitConvert["ElementaryCharge"*"BohrRadius", "Debyes"]/UnitConvert["BohrRadius", "Angstroms"]
];
dipVecs=
QuantityMagnitude@qa[[2, All, {5, 6, 7}]]-
Thread[
{
QuantityMagnitude[(qa[[2, All, 4]]-qa[[2, All, 3]])*weirdRCoeff/2],
0.,
0.
}
];
QuantityArray[
Join[
QuantityMagnitude@qa[[2, All, {1, 2, 3, 4}]],
dipVecs,
2
],
QuantityUnit@qa[[2, 1]]
]
];
$H5DipoleSurfaceQuantityArray:=
$H5DipoleSurfaceQuantityArray=getRecenteredDipoleMoments[]*)


(*$H5DipoleSurfaceQuantityArray:=
$H5DipoleSurfaceRawQuantityArray[[2]]*)


(* ::Subsubsubsection::Closed:: *)
(*New Stuff*)



(* ::Subsubsubsubsection::Closed:: *)
(*Bowtie*)



$H5DipoleSurfaceQuantityArray:=
  $H5DipoleSurfaceQuantityArray=
    Import@H5PackageFile["inputs", "dipoles.mx"];


(* ::Subsubsubsubsection::Closed:: *)
(*Parallel*)



$H5ParallelDipoleSurfaceQuantityArray:=
  $H5ParallelDipoleSurfaceQuantityArray=
    Import@H5PackageFile["inputs", "dipoles_parallel.mx"];


(* ::Subsubsection::Closed:: *)
(*Interpolation*)



(* ::Subsubsubsection::Closed:: *)
(*Bowtie*)



$H5DipoleSurfaceInterps:=
  $H5DipoleSurfaceInterps=
    Interpolation[
      QuantityMagnitude@
        $H5DipoleSurfaceQuantityArray[[All, {1, 2, 3, 4, #}]],
        {
          "ExtrapolationHandler"->{0.&, "WarningMessage"->False}
          }
        ]&/@Range[5, 7]


(* ::Subsubsubsubsection::Closed:: *)
(*Compilation*)



$H5DipoleSurfaceVec:=
  $H5DipoleSurfaceVec=
    H5VectorizedInterpCut[
      {Automatic, Automatic, Automatic, Automatic}, 
      #, 
      Automatic,
      0
      ]&/@
      $H5DipoleSurfaceInterps


(* ::Subsubsubsection::Closed:: *)
(*Parallel*)



$H5ParallelDipoleSurfaceInterps:=
  $H5ParallelDipoleSurfaceInterps=
    Interpolation[
      QuantityMagnitude@
        $H5ParallelDipoleSurfaceQuantityArray[[All, {1, 2, 3, 4, #}]],
      {
        "ExtrapolationHandler"->{0.&, "WarningMessage"->False}
        }
      ]&/@Range[5, 7]


(* ::Subsubsubsubsection::Closed:: *)
(*Compilation*)



$H5ParallelDipoleSurfaceVec:=
  $H5ParallelDipoleSurfaceVec=
    H5VectorizedInterpCut[
      {Automatic, Automatic, Automatic, Automatic}, 
      #, 
      Automatic,
      0]&/@
      $H5ParallelDipoleSurfaceInterps


(* ::Subsection:: *)
(*Outer H2 Potential*)



(* ::Subsubsection::Closed:: *)
(*outerH2Pot*)



outerH2Pot[{n1_, n2_}]:=
Module[
{
sagroups=GroupBy[QuantityMagnitude@H5FullPotQA,  #[[{3, 4}]]&->(#[[{1, 2, 5}]]&)],
R1s,
R2s,
pos
},
R1s=DeleteDuplicates@Sort@Keys[sagroups][[All, 1]];
R2s=DeleteDuplicates@Sort@Keys[sagroups][[All, 2]];
pos={R1s[[n1]], R2s[[n2]]};
If[AllTrue[pos, NumericQ], 
compiledSAPot@Interpolation@sagroups[pos],
$Failed
]
]


(* ::Subsection:: *)
(*Shared Proton Potential*)



sharedHPot[{n1_, n2_}]:=
Module[
{
h2groups=GroupBy[QuantityMagnitude@H5FullPotQA,  #[[;;2]]&->(#[[3;;]]&)],
r1s,
r2s,
pos
},
r1s=DeleteDuplicates@Sort@Keys[h2groups][[All, 1]];
r2s=DeleteDuplicates@Sort@Keys[h2groups][[All, 2]];
pos={r1s[[n1]], r2s[[n2]]};
If[AllTrue[pos, NumericQ], 
compiledSAPot@Interpolation@h2groups[pos],
$Failed
]
]


(* ::Subsection:: *)
(*$H5DVR*)



loadH5DVR[]:=
  (
    loadH5DVR["DVR"];
    loadH5DVR["Pot"];
    loadH5DVR["Settings"];
    $H5DVR
    );
If[!MatchQ[OwnValues[$H5DVR], {_:>_ChemDVRObject}],
  $H5DVR:=loadH5DVR[]
  ];


(* ::Subsubsection::Closed:: *)
(*$H5DVR*)



loadH5DVR["DVR"]:=
  $H5DVR=ChemDVRObject["Cartesian2DDVR"];


(* ::Subsubsection::Closed:: *)
(*Potential*)



(* ::Subsubsubsection::Closed:: *)
(*Old Version*)



(*h5PotOldDat=Import["~/Documents/UW/Research/H5+/inputs/2d_pot.dat","TSV"];
h5PotOldGrid=DeleteCases[h5PotOldDat,{}][[2;;,{1,2,5}]];
h5PotOldInterp=Interpolation[h5PotOldGrid];
With[{potInterp=h5PotOldInterp,dom=h5PotOldInterp[[1]]},
h5PotOld=
Compile[{{sa,_Real,1}},
With[
{
R1=1/Sqrt[2](sa[[2]]+sa[[1]]),
R2=1/Sqrt[2](sa[[2]]-sa[[1]])
},
If[dom[[1,1]]\[LessEqual]R2\[LessEqual]dom[[1,2]]&&
dom[[2,1]]\[LessEqual]R1\[LessEqual]dom[[2,2]],
potInterp[R1, R2],
10^9
]
],
RuntimeOptions\[Rule]{
"EvaluateSymbolically"\[Rule]False,
"WarningMessages"\[Rule]False
}
];
];*)


(*h5PotOldRange=
RotationMatrix[\[Pi]/4].Transpose@Tuples[h5PotOldInterp[[1]]]//Transpose//CoordinateBounds;
h5PotOldReg=
TransformedRegion[Rectangle@@Transpose@h5PotOldInterp[[1]], RotationTransform[\[Pi]/4]];*)


(* ::Subsubsubsection::Closed:: *)
(*New Version*)



loadH5DVR["Pot"]:=
  h5EqH2Pot=
    h5PotCut[
      Join[
        {Automatic, Automatic},
        {0.44687908484223565`, 0.44687908484223565`}
        ],
      -477.5763098854306`
      ];


(*Quiet@NMinimize[h5EqH2Pot[{{a, s}}], {a, s}\[Element]h5Reg]*)


(* ::Subsubsubsection::Closed:: *)
(*Difference*)



(*Plot3D[
h5EqH2Pot[{{a, s}}]-h5PotOld[{a, s}],
{a, s}\[Element]h5PotOldReg
]*)


(*h5EqH2Pot[{{a, s}}]-h5PotOld[{a, s}]/.{a\[Rule]0,s\[Rule]1.5320444241335043`}*)


(* ::Subsubsection::Closed:: *)
(*Region*)



(*{h5RegMin,h5RegMax}=Transpose@h5EqH2Pot[[1]];
h5RegUnrot=Rectangle[h5RegMin,h5RegMax];
h5Reg=Region@TransformedRegion[h5RegUnrot,RotationTransform[\[Pi]/4]];*)


loadH5DVR["Region"]:=
  (
    {h5RegMin,h5RegMax}=
      Transpose@getDomain[H5FullInterpPot, Automatic][[{3, 4}]];
    h5RegUnrot=Rectangle[h5RegMin,h5RegMax];
    h5Reg=Region@TransformedRegion[h5RegUnrot,RotationTransform[\[Pi]/4]];
    )


(* ::Subsubsection::Closed:: *)
(*Ops*)



<<ChemTools`Data`


(* ::Subsubsubsection::Closed:: *)
(*Grid*)



loadH5DVR["GridOps"]:=
  h5GridOps=
    {
      "Range"->
        With[
          {
            a = RegionBounds@h5Reg,
            b = {{-10, 10}, {0, 4}}
            },
          MapThread[
            {Max@{#[[1]], #2[[1]]}, Min@{#[[2]], #2[[2]]}}&,
            {a, b}
            ]
          ],
      "Points"->{60,60}
      };


(* ::Subsubsubsection::Closed:: *)
(*KE*)



loadH5DVR["KEOps"]:=
  (
    h5HMass=
      ChemDataLookup["H", "NISTMass"];
    h5KEOps=
      {
        "HBar"->
          QuantityMagnitude@
            ChemDataLookup["DVRHBarInAMUWavenumbers", "Constants"],
        "Mass"->
          With[
            {
              hMass=
                QuantityMagnitude@
                  UnitConvert[h5HMass,"AtomicMassUnit"]
              },
            {
              (hMass*(2hMass (*+ 2hMass*)))/
                (hMass+(2hMass + 2hMass)), 
              2*hMass
              }
            ],
        "ScalingFactor"->
          (1/QuantityMagnitude@UnitConvert["Angstroms", "Centimeters"]^2)
        };
    )


(* ::Subsubsubsection::Closed:: *)
(*PE*)



loadH5DVR["PEOps"]:=
  h5PEOps=
    {
      "PotentialFunction":>
      h5EqH2Pot
      };


(* ::Subsubsubsection::Closed:: *)
(*Run*)



loadH5DVR["RunOps"]:=
  h5RunOps=
    {
      Monitor->False,
      "SaveKineticEnergy"->False,
      "LoadKineticEnergy"->False
      };


(* ::Subsubsubsection::Closed:: *)
(*Plot*)



loadH5DVR["PlotOps"]:=
(
  If[OwnValues@h5PotMinMax=={},
    h5PotMinMax:=
      h5PotMinMax=
        Map[#[h5EqH2Pot[{x,y}],{x,y}\[Element]RegionResize[h5Reg,Scaled[.95]]]&,
          {
            NMinValue,
            NMaxValue
            }
          ]
    ];
  h5RegMemFunc=
    RegionMember@RegionResize[h5Reg, Scaled[.95]];
  h5ColFun:=
    With[{
        cf=ColorData["M10DefaultDensityGradient"],
        mm=h5PotMinMax,
        pot=h5Pot
        },
      cf[Rescale[pot[{#,#2}],mm,{0,1}]]&
      ];
  h5PlotOps=
    {
  
      "PotentialStyle"->None,
      "ShowEnergy"->False,
      PlotRange->All,
      RegionFunction:>
        With[{rf=h5RegMemFunc}, rf[{#, #2}]&],
      "WavefunctionSelection"->1,
      ColorFunction:>h5ColFun,
      ColorFunctionScaling->False,
      Lighting->"Neutral",
      Manipulate->False
      };
  )


(* ::Subsubsubsection::Closed:: *)
(*$H5Settings*)



loadH5DVR["Settings"]:=
  (
    loadH5DVR["Region"];
    loadH5DVR["GridOps"];
    loadH5DVR["KEOps"];
    loadH5DVR["PEOps"];
    loadH5DVR["RunOps"];
    loadH5DVR["PlotOps"];
    $H5DVR["RuntimeOptions"]=
      Flatten@
      {
        "GridOptions"->
          h5GridOps,
        "KineticEnergyOptions"->
          h5KEOps,
        "PotentialEnergyOptions"->
          h5PEOps,
        "ViewOptions":>
          h5PlotOps,
        h5RunOps
        };
    )


(* ::Subsection:: *)
(*$D5DVR*)



loadD5DVR[]:=
  (
    loadD5DVR["DVR"];
    loadH5DVR["Pot"];
    loadD5DVR["Settings"];
    $D5DVR
    );
If[!MatchQ[OwnValues[$D5DVR], {_:>_ChemDVRObject}],
  $D5DVR:=loadD5DVR[]
  ];


(* ::Subsubsection::Closed:: *)
(*$D5DVR*)



loadD5DVR["DVR"]:=
  $D5DVR=ChemDVRObject["Cartesian2DDVR"];


(* ::Subsubsection::Closed:: *)
(*Ops*)



<<ChemTools`Data`


(* ::Subsubsubsection::Closed:: *)
(*KE*)



loadD5DVR["KEOps"]:=
  (
    d5DMass=
      ChemDataLookup["D", "NISTMass"];
    d5KEOps=
      {
        "HBar"->
          QuantityMagnitude@
            ChemDataLookup["DVRHBarInAMUWavenumbers", "Constants"],
        "Mass"->
          With[
            {
              hMass=
                QuantityMagnitude@
                  UnitConvert[d5DMass, "AtomicMassUnit"]
              },
            {
              (hMass*2*hMass)/
                (hMass+2*(2*hMass)), 
              2*hMass
              }
            ],
        "ScalingFactor"->
          (1/QuantityMagnitude@UnitConvert["Angstroms", "Centimeters"]^2)
        };
    )


(* ::Subsubsubsection::Closed:: *)
(*$D5Settings*)



loadD5DVR["Settings"]:=
  (
    loadH5DVR["Region"];
    loadH5DVR["GridOps"];
    loadD5DVR["KEOps"];
    loadH5DVR["PEOps"];
    loadH5DVR["RunOps"];
    loadH5DVR["PlotOps"];
    $D5DVR["RuntimeOptions"]=
      Flatten@
      {
        "GridOptions"->
          h5GridOps,
        "KineticEnergyOptions"->
          d5KEOps,
        "PotentialEnergyOptions"->
          h5PEOps,
        "ViewOptions"->
          h5PlotOps,
        h5RunOps
        };
    )


(* ::Subsection:: *)
(*Single H2 Potential*)
 


(* ::Subsubsubsection::Closed:: *)
(*Bowtie*)



(*NMinimize[
H5FullInterpPot[r, r, R, R],
{r, R}\[Element]Apply[Cuboid, Transpose@H5FullInterpPot[[1, {1, 3}]]]
]*)


optR=1.0698239104916123`;
optr=0.3977482275218416`;
With[
{
potInterp=H5FullInterpPot,
eqR1=optR,
eqR2=optR,
eqr2=optr
},
h2SinglePot=
Compile[{{r1, _Real}},
potInterp[r1, eqr2, eqR1, eqR2],
RuntimeOptions->{
"EvaluateSymbolically"->False,
"WarningMessages"->False
}
]
];


(* ::Subsubsubsection::Closed:: *)
(*Old*)



optR=1.0698239104916123`;
optr=0.3977482275218416`;
With[
{
potInterp=$H5OldInterpPot,
eqR1=optR,
eqR2=optR,
eqr2=optr
},
h2OldSinglePot=
Compile[{{r1, _Real}},
potInterp[r1, eqr2, eqR1, eqR2],
RuntimeOptions->{
"EvaluateSymbolically"->False,
"WarningMessages"->False
}
]
];


(* ::Subsubsubsection::Closed:: *)
(*Parallel*)



optR=1.071351775879906`;
optr=0.39730604197629976`;
With[
{
potInterp=$H5ParallelFullInterpPot,
eqR1=optR,
eqR2=optR,
eqr2=optr
},
h2ParallelSinglePot=
Compile[{{r1, _Real}},
potInterp[r1, eqr2, eqR1, eqR2],
RuntimeOptions->{
"EvaluateSymbolically"->False,
"WarningMessages"->False
}
]
];


(* ::Subsection:: *)
(*Outer H2 Potential*)



(* ::Subsubsection::Closed:: *)
(*Eq Pot*)



With[
{
potInterp=H5FullInterpPot,
dom=H5FullInterpPot[[1]],
eqR1=1.068237,
eqR2=1.068237,
h2Min=-461.45688769022894`
},
h2Pot=
Compile[{{r1r2,_Real,1}},
With[
{
r1=r1r2[[1]],
r2=r1r2[[2]]
},
potInterp[r1, r2, eqR1, eqR2]
],
RuntimeOptions->{
"EvaluateSymbolically"->False,
"WarningMessages"->False
},
RuntimeAttributes->{Listable}
];
h2PotZPE=
Compile[{{r1r2,_Real,1}},
With[
{
r1=r1r2[[1]],
r2=r1r2[[2]]
},
potInterp[r1, r2, eqR1, eqR2]-h2Min
],
RuntimeOptions->{
"EvaluateSymbolically"->False,
"WarningMessages"->False
},
RuntimeAttributes->{Listable}
];
h2PotVec=
Quiet@
Compile[{{r1r2,_Real,2}},
With[
{
pts=Transpose@Map[Join[#, {eqR1, eqR2}]&, r1r2]
},
potInterp@@pts
],
RuntimeOptions->{
"EvaluateSymbolically"->False,
"WarningMessages"->False
},
RuntimeAttributes->{Listable}
];
];


(*Quiet@NMinimize[h2Pot[{x, y}], {x, y}\[Element]Rectangle[{.256, .256}, {2, 2}]]*)


(*Quiet@NMinimize[h2PotZPE[{x, y}], {x, y}\[Element]Rectangle[{.256, .256}, {2, 2}]]*)


(* ::Subsubsection::Closed:: *)
(*Multi Pot*)



h2Pots=<||>;
h2PotVecs=<||>;
With[
{
potInterp=H5FullInterpPot,
dom=H5FullInterpPot[[1]],
eqR2=1.510716
},
Map[
With[{bigR1=#},
h2Pots[{bigR1, eqR2}]:=
h2Pots[{bigR1, eqR2}]=
Compile[{{r1r2,_Real,1}},
With[
{
r1=r1r2[[1]],
r2=r1r2[[2]]
},
potInterp[r1, r2, bigR1, eqR2]
],
RuntimeOptions->{
"EvaluateSymbolically"->False,
"WarningMessages"->False
},
RuntimeAttributes->{Listable}
];
h2PotVecs[{bigR1, eqR2}]:=
h2PotVecs[{bigR1, eqR2}]=
Quiet@
Compile[{{r1r2,_Real,2}},
With[
{
pts=Transpose@Map[Join[#, {bigR1, eqR2}]&, r1r2]
},
potInterp@@pts
],
RuntimeOptions->{
"EvaluateSymbolically"->False,
"WarningMessages"->False
},
RuntimeAttributes->{Listable}
];
]&,
Range[1.510716, 3.26716, .25]
]
];


(* ::Subsection:: *)
(*$H2DVR*)



loadH2DVR[]:=
  (
    loadH2DVR["DVR"];
    loadH2DVR["Pot"];
    loadH2DVR["Settings"];
    $H2DVR
    );
If[!MatchQ[OwnValues[$H2DVR], {_:>_ChemDVRObject}],
  $H2DVR:=loadH2DVR[]
  ];


(* ::Subsubsection::Closed:: *)
(*DVR*)



loadH2DVR["DVR"]:=
  $H2DVR=ChemDVRObject["Cartesian2DDVR"];


(* ::Subsubsection::Closed:: *)
(*Ops*)



(* ::Subsubsubsection::Closed:: *)
(*Region*)



loadH2DVR["Region"]:=
  h2Reg=
    Region@
      Apply[Rectangle, 
        {
          getDomain[H5FullInterpPot, Automatic][[{1, 2}, 1]],
          {1., 1.}
          }
        ];


(* ::Subsubsubsection::Closed:: *)
(*Grid*)



loadH2DVR["GridOps"]:=
  h2GridOps=
    {
      "Range"->RegionBounds[h2Reg],
      "Points"->{125, 125}
      };


(* ::Subsubsubsection::Closed:: *)
(*KE*)



loadH2DVR["KEOps"]:=
  (
    h5HMass=
      ChemDataLookup["H", "NISTMass"];
  h2KEOps=
    {
      "HBar"->
        QuantityMagnitude@
            ChemDataLookup["DVRHBarInAMUWavenumbers", "Constants"],
      "Mass"->
        2*QuantityMagnitude@(h5HMass),
      "ScalingFactor"->
        (1/QuantityMagnitude@UnitConvert["Angstroms", "Centimeters"]^2)
      };
  )


(* ::Subsubsubsection::Closed:: *)
(*PE*)



loadH2DVR["PEOps"]:=
  h2PEOps=
    {
      "PotentialFunction"->h2Pot
      };


(* ::Subsubsubsection::Closed:: *)
(*PO*)



loadH2DVR["POOps"]:=
  h2POOps=
    {
      "PotentialFunction"->h2SinglePot,
      "OptimizedBasisSize"->25
      };


(* ::Subsubsubsection::Closed:: *)
(*Plot*)



(*

{-515.6441078856749`,62529.8885143045`}*)


loadH2DVR["PlotOps"]:=
(
  If[Length@OwnValues[h2PotMinMax]==0,
    h2PotMinMax=
      Quiet@Map[#[h2Pot[{x,y}],{x,y}\[Element]RegionResize[h2Reg,Scaled[.95]]]&,
        {
          NMinValue,
          NMaxValue
          }
        ]
    ];
  h2RegMemFunc=
    RegionMember@RegionResize[h2Reg,Scaled[.95]];
  h2ColFun=
    With[{
        cf=ColorData["M10DefaultDensityGradient"],
        mm=h2PotMinMax,
        pot=h2Pot
        },
      cf[Rescale[pot[{#,#2}],mm,{0,1}]]&
      ];
  h2PlotOps=
    {
      "PotentialStyle"->None,
      "ShowEnergy"->False,
      PlotRange->All,
      RegionFunction->h2RegMemFunc,
      ColorFunction->h2ColFun,
      ColorFunctionScaling->False,
      Lighting->"Neutral",
      Manipulate->False
      };
  )


(* ::Subsubsubsection::Closed:: *)
(*Run*)



loadH2DVR["RunOps"]:=
  h2RunOps=
    {
      Monitor->False,
      "SaveKineticEnergy"->False,
      "LoadKineticEnergy"->False
      };


(* ::Subsubsubsection::Closed:: *)
(*$H2Settings*)



loadH2DVR["Settings"]:=
(
  loadH2DVR["Region"];
  loadH2DVR["GridOps"];
  loadH2DVR["KEOps"];
  loadH2DVR["PEOps"];
  loadH2DVR["POOps"];
  loadH2DVR["PlotOps"];
  loadH2DVR["RunOps"];
  $H2DVR["RuntimeOptions"]=
    Flatten@
      {
        "GridOptions"->
          h2GridOps,
        "KineticEnergyOptions"->
          h2KEOps,
        "PotentialEnergyOptions"->
          h2PEOps,
        "PotentialOptimizationOptions"->
          h2POOps,
        "ViewOptions"->
          h2PlotOps,
        h2RunOps
        };
  )


(* ::Subsection:: *)
(*$D2DVR*)



loadD2DVR[]:=
  (
    loadD2DVR["DVR"];
    loadH2DVR["Pot"];
    loadD2DVR["Settings"];
    $D2DVR
    );
If[!MatchQ[OwnValues[$D2DVR], {_:>_ChemDVRObject}],
  $D2DVR:=loadD2DVR[]
  ];


(* ::Subsubsection::Closed:: *)
(*DVR*)



loadD2DVR["DVR"]:=
  $D2DVR=ChemDVRObject["Cartesian2DDVR"];


(* ::Subsubsection::Closed:: *)
(*Ops*)



(* ::Subsubsubsection::Closed:: *)
(*KE*)



loadD2DVR["KEOps"]:=
  (
    d5DMass=
      ChemDataLookup["D", "NISTMass"];
  d2KEOps=
    {
      "HBar"->
        QuantityMagnitude@
          ChemDataLookup["DVRHBarInAMUWavenumbers", "Constants"],
      "Mass"->
        2*QuantityMagnitude@(d5DMass),
      "ScalingFactor"->
        (1/QuantityMagnitude@UnitConvert["Angstroms", "Centimeters"]^2)
      };
  )


(* ::Subsubsubsection::Closed:: *)
(*$D2Settings*)



loadD2DVR["Settings"]:=
(
  loadH2DVR["Region"];
  loadH2DVR["GridOps"];
  loadD2DVR["KEOps"];
  loadH2DVR["PEOps"];
  loadH2DVR["POOps"];
  loadH2DVR["PlotOps"];
  loadH2DVR["RunOps"];
  $D2DVR["RuntimeOptions"]=
    Flatten@
      {
        "GridOptions"->
          h2GridOps,
        "KineticEnergyOptions"->
          d2KEOps,
        "PotentialEnergyOptions"->
          h2PEOps,
        "PotentialOptimizationOptions"->
          h2POOps,
        "ViewOptions"->
          h2PlotOps,
        h2RunOps
        };
  )


(* ::Subsection:: *)
(*$H2SingleDVR*)



loadH2SDVR[]:=
  (
    loadH2SDVR["DVR"];
    loadH2SDVR["Pot"];
    loadH2SDVR["Settings"];
    $H2SingleDVR
    );
If[!MatchQ[OwnValues[$H2SingleDVR], {_:>_ChemDVRObject}],
  $H2SingleDVR:=loadH2SDVR[]
  ];


(* ::Subsubsection::Closed:: *)
(*DVR*)



loadH2SDVR["DVR"]:=
  $H2SingleDVR=ChemDVRObject["Cartesian1DDVR"];


(* ::Subsubsection::Closed:: *)
(*Ops*)



<<ChemTools`Data`


(* ::Subsubsubsection::Closed:: *)
(*Region*)



loadH2SDVR["Region"]:=
  h2SingleReg=
    Region@
      Interval[
        {
          getDomain[H5FullInterpPot, Automatic][[1, 1]], 
          1
          }
        ];


(* ::Subsubsubsection::Closed:: *)
(*Grid*)



loadH2SDVR["GridOps"]:=
h2SingleGridOps=
  {
    "Range"->RegionBounds[h2SingleReg],
    "Points"->250
    };


(* ::Subsubsubsection::Closed:: *)
(*KE*)



loadH2SDVR["KEOps"]:=
(
h5HMass=
  UnitConvert[
    Quantity[
      2*ChemTools`Data`RawDatasets`$ChemIsotopicMasses[1, 1, "Mass"],
      "AtomicMassUnit"
      ],
    "Kilograms"
    ];
h2SingleKEOps=
  {
    "HBar"->
      QuantityMagnitude@
        UnitConvert[
          Quantity["ReducedPlanckConstant"]/
            Sqrt[Quantity["PlanckConstant"*"SpeedOfLight"]],
          Sqrt["Kilograms"]*Sqrt["Centimeters"]
          ],
    "Mass"->
      QuantityMagnitude@h5HMass,
    "ScalingFactor"->
      (1/QuantityMagnitude@UnitConvert["Angstroms", "Centimeters"]^2)
    };
)


(* ::Subsubsubsection::Closed:: *)
(*PE*)



loadH2SDVR["PEOps"]:=
h2SinglePEOps=
  {
    "PotentialFunction"->h2SinglePot
    };


(* ::Subsubsubsection::Closed:: *)
(*Run*)



loadH2SDVR["RunOps"]:=
h2SingleRunOps=
  {
    Monitor->False,
    "SaveKineticEnergy"->False,
    "LoadKineticEnergy"->False
    };


(* ::Subsubsubsection::Closed:: *)
(*Plot*)



loadH2SDVR["PlotOps"]:=
(
h2SinglePotMinMax:=
  h2SinglePotMinMax=
    Map[#[h2SinglePot[x],{x}\[Element]h2SingleReg]&,
      {
        NMinValue,
        NMaxValue
        }
      ];
h2SingleColFun:=
  h2SingleColFun=
    With[{
        cf=ColorData["M10DefaultDensityGradient"],
        mm=h2SinglePotMinMax,
        pot=h2SinglePot
        },
      cf[Rescale[pot[#],mm,{0,1}]]&
      ];
h2SinglePlotOps=
  {
    "PotentialStyle"->None,
    "ShowEnergy"->False,
    "ShowPotential"->False,
    ColorFunction:>h2SingleColFun,
    ColorFunctionScaling->False,
    Lighting->"Neutral",
    Manipulate->False
    };
)


(* ::Subsubsubsection::Closed:: *)
(*$H2Settings*)



loadH2SDVR["Settings"]:=(

loadH2SDVR["Region"];
loadH2SDVR["GridOps"];
loadH2SDVR["KEOps"];
loadH2SDVR["PEOps"];
loadH2SDVR["POOps"];
loadH2SDVR["PlotOps"];
loadH2SDVR["RunOps"];

$H2SingleDVR["RuntimeOptions"]=
  Flatten@
    {
      "GridOptions"->
        h2SingleGridOps,
      "KineticEnergyOptions"->
        h2SingleKEOps,
      "PotentialEnergyOptions"->
        h2SinglePEOps,
      "ViewOptions"->
        h2SinglePlotOps,
      h2SingleRunOps
      };
      
)


(* ::Subsection:: *)
(*$D2SingleDVR*)



loadD2SDVR[]:=
  (
    loadD2SDVR["DVR"];
    loadH2SDVR["Pot"];
    loadD2SDVR["Settings"];
    $D2SingleDVR
    );
If[!MatchQ[OwnValues[$D2SingleDVR], {_:>_ChemDVRObject}],
  $D2SingleDVR:=loadD2SDVR[]
  ];


(* ::Subsubsection::Closed:: *)
(*DVR*)



loadD2SDVR["DVR"]:=
  $D2SingleDVR=ChemDVRObject["Cartesian1DDVR"];


(* ::Subsubsection::Closed:: *)
(*Ops*)



<<ChemTools`Data`


(* ::Subsubsubsection::Closed:: *)
(*KE*)



loadD2SDVR["KEOps"]:=
(
  d5D2Mass=
    2*ChemDataLookup["D", "NISTMass"];
  d2SingleKEOps=
    {
      "HBar"->
        QuantityMagnitude@
          ChemDataLookup["DVRHBarInAMUWavenumbers", "Constants"],
      "Mass"->
        QuantityMagnitude@d5D2Mass,
      "ScalingFactor"->
        (1/QuantityMagnitude@UnitConvert["Angstroms", "Centimeters"]^2)
      };
  )


(* ::Subsubsubsection::Closed:: *)
(*$D2Settings*)



loadD2SDVR["Settings"]:=(

  loadH2SDVR["Region"];
  loadH2SDVR["GridOps"];
  loadD2SDVR["KEOps"];
  loadH2SDVR["PEOps"];
  loadH2SDVR["POOps"];
  loadH2SDVR["PlotOps"];
  loadH2SDVR["RunOps"];
  
  $D2SingleDVR["RuntimeOptions"]=
    Flatten@
      {
        "GridOptions"->
          h2SingleGridOps,
        "KineticEnergyOptions"->
          d2SingleKEOps,
        "PotentialEnergyOptions"->
          h2SinglePEOps,
        "ViewOptions"->
          h2SinglePlotOps,
        h2SingleRunOps
        };
        
  )


(* ::Subsection:: *)
(*H2 State Assignments*)



(* ::Subsubsubsection::Closed:: *)
(*Test*)



(*With[{gg=
Thread[{
$H2DVR[
 "Points"\[Rule]{125, 125},"ShowPotential"\[Rule]False,
 "WavefunctionClipping"\[Rule]None, "NumberOfWavefunctions"\[Rule]15,
"PlotMode"\[Rule]"Density","PlotDisplayMode"\[Rule]List,
ColorFunction->"Rainbow",
ColorFunctionScaling->True
]~TakeList~{1, 2, 3, 4, 5},
TakeList[
$H2DVR[
"Points"\[Rule]{25, 25},
"PotentialOptimize"\[Rule]False,
"UseGuessWavefunctions"\[Rule]True, 
"PotentialFunction"\[Rule](0&),
 "UncoupledPotentialFunctions"\[Rule]{h2SinglePot, h2SinglePot},
"PlotDisplayMode"\[Rule]List,
"ShowPotential"\[Rule]False, "WavefunctionClipping"\[Rule]None,
"NumberOfWavefunctions"\[Rule]15,
"PlotMode"\[Rule]"Density",
ColorFunction->"Rainbow",
ColorFunctionScaling->True
], 
{1, 2, 3, 4, 5}
]
}]
},
Manipulate[Grid@gg[[i]], {i, 1,Length@gg,1}]
]*)


(* ::Subsubsection::Closed:: *)
(*$H2StateAssignments*)



$H2StateAssignments=
<|
1->"\!\(\*TemplateBox[{RowBox[{\"0\", \",\", \"0\"}]},\n\"Ket\"]\)",
2->"\!\(\*TemplateBox[{RowBox[{\"0\", \",\", \"1\"}]},\n\"Ket\"]\)-\!\(\*TemplateBox[{RowBox[{\"1\", \",\", \"0\"}]},\n\"Ket\"]\)",
3->"\!\(\*TemplateBox[{RowBox[{\"0\", \",\", \"1\"}]},\n\"Ket\"]\)+\!\(\*TemplateBox[{RowBox[{\"1\", \",\", \"0\"}]},\n\"Ket\"]\)",
4->"\!\(\*TemplateBox[{RowBox[{\"0\", \",\", \"2\"}]},\n\"Ket\"]\)-\!\(\*TemplateBox[{RowBox[{\"2\", \",\", \"0\"}]},\n\"Ket\"]\)",
5->"\!\(\*TemplateBox[{RowBox[{\"1\", \",\", \"1\"}]},\n\"Ket\"]\)\[Angle]45",
6->"\!\(\*TemplateBox[{RowBox[{\"0\", \",\", \"2\"}]},\n\"Ket\"]\)+\!\(\*TemplateBox[{RowBox[{\"2\", \",\", \"0\"}]},\n\"Ket\"]\)",
7->"\!\(\*TemplateBox[{RowBox[{\"0\", \",\", \"3\"}]},\n\"Ket\"]\)-\!\(\*TemplateBox[{RowBox[{\"3\", \",\", \"0\"}]},\n\"Ket\"]\)",
8->"\!\(\*TemplateBox[{RowBox[{\"1\", \",\", \"2\"}]},\n\"Ket\"]\)-\!\(\*TemplateBox[{RowBox[{\"2\", \",\", \"1\"}]},\n\"Ket\"]\)",
9->"\!\(\*TemplateBox[{RowBox[{\"1\", \",\", \"2\"}]},\n\"Ket\"]\)+\!\(\*TemplateBox[{RowBox[{\"2\", \",\", \"1\"}]},\n\"Ket\"]\)",
10->"\!\(\*TemplateBox[{RowBox[{\"0\", \",\", \"3\"}]},\n\"Ket\"]\)+\!\(\*TemplateBox[{RowBox[{\"3\", \",\", \"0\"}]},\n\"Ket\"]\)",
11->"\!\(\*TemplateBox[{RowBox[{\"0\", \",\", \"4\"}]},\n\"Ket\"]\)-\!\(\*TemplateBox[{RowBox[{\"4\", \",\", \"0\"}]},\n\"Ket\"]\)",
12->"\!\(\*TemplateBox[{RowBox[{\"1\", \",\", \"3\"}]},\n\"Ket\"]\)-\!\(\*TemplateBox[{RowBox[{\"3\", \",\", \"1\"}]},\n\"Ket\"]\)",
13->"\!\(\*TemplateBox[{RowBox[{\"2\", \",\", \"2\"}]},\n\"Ket\"]\)\[Angle]45",
14->"\!\(\*TemplateBox[{RowBox[{\"1\", \",\", \"3\"}]},\n\"Ket\"]\)+\!\(\*TemplateBox[{RowBox[{\"3\", \",\", \"1\"}]},\n\"Ket\"]\)",
15->"\!\(\*TemplateBox[{RowBox[{\"0\", \",\", \"4\"}]},\n\"Ket\"]\)+\!\(\*TemplateBox[{RowBox[{\"4\", \",\", \"0\"}]},\n\"Ket\"]\)"
|>;


(* ::Subsection:: *)
(*$H54DDVR*)



loadH54DVR[]:=
  (
    loadH54DVR["DVR"];
    loadH54DVR["Pot"];
    loadH54DVR["Settings"];
    $H54DDVR
    );
$H54DDVR:=loadH54DVR[];


(* ::Subsubsection::Closed:: *)
(*$H54DDVR*)



loadH54DVR["DVR"]:=
  $H54DDVR=ChemDVRObject["Cartesian4DDVR"];


(* ::Subsubsection::Closed:: *)
(*Region*)



loadH54DVR["Region"]:=
(
  {h54DRegMin,h54DRegMax}=
    Transpose@H5FullInterpPot[[1, 3;;4]];
  h54DRegUnrot=Rectangle[h54DRegMin,h54DRegMax];
  h54DReg=Region@TransformedRegion[h54DRegUnrot,RotationTransform[\[Pi]/4]];
    h54DReg//RegionBounds
)


(* ::Subsubsubsection::Closed:: *)
(*Tests*)



(*Show[
Graphics@{
Red,
Show[h54DTReg][[1]] 
},
Graphics[{Yellow, h54DTRegUnrot}],
Graphics[{Blue, h54DRegUnrot}],
Show@h54DReg,
Graphics[
{
{
Pink,
testGrid[[All, ;;2]]//Point
},
{
Green,
1/Sqrt[2]*{(#[[2]]-#[[1]]), (#[[1]]+#[[2]])}&/@
testGrid//Point
}
}
],
Axes\[Rule]True,
AxesOrigin\[Rule]{0, 0}
]*)


(*h54DTRegUnrot=Rectangle@@Transpose[h54DReg//RegionBounds];
h54DTReg=Region@TransformedRegion[h54DTRegUnrot,RotationTransform[-\[Pi]/4]];
h54DTReg//RegionBounds*)


(* ::Subsubsection::Closed:: *)
(*Ops*)



<<ChemTools`Data`


(* ::Subsubsubsection::Closed:: *)
(*Grid*)



loadH54DVR["GridOps"]:=
  h54DGridOps=
    {
      "Range"->
      Join[
        h54DReg//RegionBounds,
        {{0.25`,2.25`},{0.25`,2.25`}}
        ],
      "Points"->{30, 30, 125, 125}
      };


(* ::Subsubsubsection::Closed:: *)
(*KE*)



loadH54DVR["GridOps"]:=
(
h5HMass=
  Quantity[
    ChemTools`Data`RawDatasets`$ChemIsotopicMasses[1, 1, "Mass"],
    "AtomicMassUnit"
    ];
h54DKEOps=
  {
    "HBar"->
      QuantityMagnitude@
        UnitConvert[
          Quantity["ReducedPlanckConstant"]/Sqrt[Quantity["PlanckConstant"*"SpeedOfLight"]],
          Sqrt["Kilograms"]*Sqrt["Centimeters"]
          ],
    "Mass"->
      {
        With[
          {
            hMass=
            QuantityMagnitude@
            UnitConvert[h5HMass,"Kilograms"]
            },
          (hMass (2*hMass))/(hMass+ 2(2*hMass))
          ],
        2*QuantityMagnitude@
          UnitConvert[h5HMass,"Kilograms"],
        2*QuantityMagnitude@
          UnitConvert[h5HMass,"Kilograms"],
        2*QuantityMagnitude@
          UnitConvert[h5HMass,"Kilograms"]
        },
    "ScalingFactor"->
      (1/QuantityMagnitude@UnitConvert["Angstroms", "Centimeters"]^2)
    };
)


(* ::Subsubsubsection::Closed:: *)
(*PE*)



loadH54DVR["PEOps"]:=
  h54DPEOps=
    {
      "PotentialFunction"->H5FullPot
      };


(* ::Subsubsubsection::Closed:: *)
(*Run*)



loadH54DVR["RunOps"]:=
  h54DRunOps=
    {
      Monitor->False,
      "SaveKineticEnergy"->False,
      "LoadKineticEnergy"->False
      };


(* ::Subsubsubsection::Closed:: *)
(*Plot*)



loadH54DVR["PlotOps"]:=
  h54DPlotOps=
    {
      "PotentialStyle"->None,
      "ShowEnergy"->False,
      PlotRange->All,
      Manipulate->False
      };


(* ::Subsubsubsection::Closed:: *)
(*PO*)



loadH54DVR["POOps"]:=
  h54DPotOptOps=
    {
      "PotentialFunction"->{None, None, h2SinglePot, h2SinglePot},
      "OptimizedCoordinates"->{3, 4},
      "OptimizedBasisSize"->25
      };


(* ::Subsubsubsection::Closed:: *)
(*$H54DSettings*)



loadH54DVR["Settings"]:=
(
  loadH54DVR["Region"];
  loadH54DVR["GridOps"];
  loadH54DVR["PEOps"];
  loadH54DVR["KEOps"];
  loadH54DVR["POOps"];
  loadH54DVR["PlotOps"];
  loadH54DVR["RunOps"];
  $H54DDVR["RuntimeOptions"]=
    Flatten@
      {
        "GridOptions"->
          h54DGridOps,
        "KineticEnergyOptions"->
          h54DKEOps,
        "PotentialEnergyOptions"->
          h54DPEOps,
        "ViewOptions"->
          h54DPlotOps,
        "PotentialOptimizationOptions"->
          h54DPotOptOps,
        h54DRunOps
        };
  )


(* ::Subsection:: *)
(*Plot5D*)



If[Length@OwnValues@$H54DGrid==0,
$H54DGrid:=
$H54DGrid=$H54DDVR["Grid"]
];


(* ::Subsubsection::Closed:: *)
(*ListPlot5D*)



ListPlot5D//Clear
ListPlot5D[
gridwfns_,
n:_Span|{__Integer}|All:All,
coords:({_, _}->{_, _}):({3, 4}->{2, 1}),
 ops:OptionsPattern[ListPlot3D]
]:=
Module[
{
groupedWfns,
potMinMaxes,
wfnCutPlots
},
groupedWfns=
With[{c1=coords[[1]], c2=Append[coords[[2]], 5]},
GroupBy[
Flatten/@#,
Function[#[[c1]]]->Function[#[[c2]]]
][[n]]&/@gridwfns
];
potMinMaxes=
With[{order=Ordering[Join[coords[[2]], coords[[1]]]]},
MapIndexed[
MinMax@
DeleteCases[
H5FullVecPot[
Flatten[#][[order]]&/@
Thread[{#[[All, ;;2]], ConstantArray[#2[[1, 1]],Length@#]}]
],
10.^9
]&,
KeySort[#]
]
]&/@groupedWfns;
wfnCutPlots=
MapThread[
With[
{minMax=#2},
KeyValueMap[
ListPlot3D[
#2,
PlotLabel->TemplateApply["`1`: `3` `2`: `4`", Join[coords[[1]], #]],
ColorFunction->
Replace[OptionValue[ColorFunction],
Automatic:>
With[
{
minmax=minMax[#], 
cf=ColorData["M10DefaultDensityGradient"],
crds=Sequence@@#,
order=Ordering[Join[coords[[2]], coords[[1]]]]
},
cf@
Rescale[
H5FullPot[{#, #2, crds}[[order]]],
minmax,
{0,1}
]&
]
],
ColorFunctionScaling->
Replace[OptionValue[ColorFunction],
{
Automatic->False,
_:>OptionValue[ColorFunctionScaling]
}
];
ops,
PlotRange->All
]&,
KeySort[#]
]
]&,
{groupedWfns,
potMinMaxes
}
]
];


(* ::Subsubsection::Closed:: *)
(*ListDensityPlot5D*)



ListDensityPlot5D//Clear
ListDensityPlot5D[
gridwfns_,
n:_Span|{__Integer}|All:All,
coords:(_Integer->{_, _, _}):(1->{1, 2, 3}),
ops:OptionsPattern[ListDensityPlot3D]
]:=
Module[
{
groupedWfns,
groupedWfnsR1,
potMinMaxes,
wfnCutPlots
},
groupedWfns=
With[{c1=coords[[1]], c2=Append[coords[[2]], 5]},
GroupBy[
Flatten/@#,
Function[#[[c1]]]->Function[#[[c2]]]
][[n]]&/@gridwfns
];
potMinMaxes=
With[
{
order=
Ordering[Flatten[{coords[[2]], coords[[1]]}]]
},
MapIndexed[
MinMax@
DeleteCases[
H5FullVecPot[
Flatten[#][[order]]&/@
Thread[{#[[All, ;;2]], ConstantArray[#2[[1, 1]],Length@#]}]
],
10.^9
]&,
KeySort[#]
]
]&/@groupedWfns;
wfnCutPlots=
KeyValueMap[
ListDensityPlot3D[
#2,
PlotLabel->TemplateApply["``: ``", {coords[[1]], #}],
ColorFunction->
Replace[OptionValue[ColorFunction],
Automatic:>
With[
{
minmax=potMinMaxes[#], 
cf=ColorData["M10DefaultDensityGradient"],
r1r2=Sequence@@#
},
cf@
Rescale[
H5FullPot[{#, #2, r1r2}],
minmax,
{0,1}
]&
]
],
ColorFunctionScaling->
Replace[OptionValue[ColorFunction],
{
Automatic->False,
_:>OptionValue[ColorFunctionScaling]
}
];
ops,
OpacityFunction->Function[If[#<.8, 0, -4+5#]],
PlotRange->All
]&,
KeySort[#]
]&/@groupedWfns
];


(* ::Subsubsection::Closed:: *)
(*H54DPlot*)



H54DPlot//Clear
H54DPlot[wfns_, 
n:_Span|{__Integer}|All:All,
coords:(_Integer->{_, _, _}):({3, 4}->{1, 2}),
ops:OptionsPattern[Plot3D]]:=
ListPlot5D[
$H54DDVR["GridWavefunctions",
 "Wavefunctions"->wfns,
"Grid"->$H54DGrid
],
n,
coords,
ops
]


(* ::Subsubsection::Closed:: *)
(*H54DDensityPlot*)



H54DDensityPlot//Clear
H54DDensityPlot[wfns_,
n:_Span|{__Integer}|All:All,
coords:(_Integer->{_, _, _}):(3->{1, 2, 4}),
ops:OptionsPattern[DensityPlot3D]]:=
ListDensityPlot5D[
$H54DDVR["GridWavefunctions", 
 "Wavefunctions"->wfns,
"Grid"->$H54DGrid
],
n,
coords,
ops
]


(* ::Subsection:: *)
(*PlotSpec*)



(* ::Subsubsection::Closed:: *)
(*Prep*)



H5SpecPrep//Clear
H5SpecPrep[
specPts:{{_, _?NumericQ}, ___}, 
range:{_?NumericQ,_?NumericQ}|Automatic:Automatic,
scaling:Scaled[_?NumericQ]|Automatic:Automatic,
shiftScale:Offset[_?NumericQ, Scaled[_?NumericQ]]|Offset[_?NumericQ]|Automatic:Automatic,
threshold:_?(0<#<1&)|Automatic:Automatic
]:=
Module[
{sps, 
rang=Replace[range, Automatic->{-\[Infinity], \[Infinity]}],
scale=Replace[scaling, Automatic->Scaled[1]][[1]],
shif=Replace[shiftScale, {Automatic->0, Offset[s_, ___]:>s}],
spacescale=Replace[shiftScale, {Offset[_, Scaled[n_]]:>n, _->1}],
thresh=Replace[threshold, Automatic->.001],
spmin
},
sps=specPts+ConstantArray[{shif, 0}, Length@specPts];
sps=Select[sps, rang[[1]]<#[[1]]<rang[[2]]&];
sps/=ConstantArray[{1, Max@sps[[All, 2]]}, Length@sps];
sps=Select[sps, #[[2]]>thresh&];
spmin=Min@sps[[All, 1]];
sps-=ConstantArray[{spmin, 0}, Length@sps];
sps*=ConstantArray[{spacescale, 1}, Length@sps];
sps+=ConstantArray[{spmin, 0}, Length@sps];
sps*=ConstantArray[{1, scale},Length@sps];
sps
]


(* ::Subsubsection::Closed:: *)
(*Lines*)



H5PlotSpecLines//Clear
H5PlotSpecLines[
specPts:{{_, _?NumericQ}, ___}, 
range:{_?NumericQ,_?NumericQ}|Automatic:Automatic,
scaling:Scaled[_?NumericQ]|Automatic:Automatic,
shift:Offset[_?NumericQ, Scaled[_?NumericQ]]|Offset[_?NumericQ]|Automatic:Automatic,
threshold:_?(0<#<1&)|Automatic:Automatic,
ops:OptionsPattern[ListPlot]
]:=
ListPlot[
H5SpecPrep[specPts, range, scaling ,shift, threshold] ,
ops, 
Filling->Axis, FillingStyle->Red, PlotMarkers->"",
Axes->{True, False},
PlotRange->All
]


(* ::Subsubsection::Closed:: *)
(*Std*)



If[!MatchQ[OwnValues[h5SampleSpectrum], {_:>_Image}],
  h5SampleSpectrum:=
    h5SampleSpectrum=
      Import["~/Documents/UW/Research/H5+/Common/SampleSpectrum.png"]
  ];


(* ::Subsubsubsection::Closed:: *)
(*Lines*)



H5PlotSpec//Clear
H5PlotSpec[
specPts:{{_, _?NumericQ}, ___}, 
shift:Offset[_?NumericQ, Scaled[_?NumericQ]]|Offset[_?NumericQ]|Automatic:Automatic,
threshold:_?(0<#<1&)|Automatic:Automatic,
ops:OptionsPattern[ListPlot]
]:=
Overlay[
{
Image[h5SampleSpectrum,ImageSize->ImageDimensions[h5SampleSpectrum]/2],
H5PlotSpecLines[ 
specPts,
{4750, 7350},
Scaled[.85],
shift,
threshold,
PlotRange->{{4750, 7350}, {0, 1}},
ImageSize->ImageDimensions[h5SampleSpectrum]/2-{0, 33},
AspectRatio->Full,
Axes->False,
Ticks->None,
ops
]
}
]


(* ::Subsubsubsection::Closed:: *)
(*Distribution*)



H5PlotSpecBroadened//Clear
H5PlotSpecBroadened[
specPts:{{_, _?NumericQ}, ___}, 
broadening_?NumericQ,
shift:Offset[_?NumericQ, Scaled[_?NumericQ]]|Offset[_?NumericQ]|Automatic:Automatic,
threshold:_?(0<#<1&)|Automatic:Automatic,
ops:OptionsPattern[ListPlot]
]:=
Overlay[
{
Image[h5SampleSpectrum,ImageSize->ImageDimensions[h5SampleSpectrum]/2],
H5SpecGaussianBroadenedSpectrum[ 
specPts,
broadening,
{4750, 7350},
Scaled[.85],
shift,
threshold,
PlotRange->{{4750, 7350}, {0, 1}},
ImageSize->ImageDimensions[h5SampleSpectrum]/2-{0, 33},
AspectRatio->Full,
Axes->False,
Ticks->None,
ops
]
}
]


(* ::Subsubsection::Closed:: *)
(*Distributions*)



(* ::Text:: *)
(*This should be in the Graphics or something. At min the spectral processing stuff needs an update to work like this.*)



(* ::Text:: *)
(*Done (10/20/2018)*)



(* ::Subsubsubsection::Closed:: *)
(*General*)



H5SpecDistribution//Clear
H5SpecDistribution[
specPts:{{_, _?NumericQ}, ___},
distFuncs:{_Function|_Symbol, _Function|_Symbol}, 
range:{_?NumericQ,_?NumericQ}|Automatic:Automatic,
scaling:Scaled[_?NumericQ]|Automatic:Automatic,
shift:Offset[_?NumericQ, Scaled[_?NumericQ]]|Offset[_?NumericQ]|Automatic:Automatic,
threshold:_?(0<#<1&)|Automatic:Automatic
]:=
Module[
{
sps,
ints,
pos,
dists,
weights
},
sps=H5SpecPrep[specPts, range,scaling,shift,threshold];
ints=sps[[All, 2]];
pos=sps[[All, 1]];
dists=distFuncs[[1]]/@pos;
weights=MapThread[distFuncs[[2]], {ints,dists}];
MixtureDistribution[
Max[ints]*weights/Max[weights],
dists
]
]


(* ::Subsubsubsection::Closed:: *)
(*Gaussian Broadening*)



H5SpecGaussianBroadening//Clear
H5SpecGaussianBroadening[
specPts:{{_, _?NumericQ}, ___}, 
broadness_?(NumericQ[#]&&Positive[#]&),
range:{_?NumericQ,_?NumericQ}|Automatic:Automatic,
scaling:Scaled[_?NumericQ]|Automatic:Automatic,
shift:Offset[_?NumericQ, Scaled[_?NumericQ]]|Offset[_?NumericQ]|Automatic:Automatic,
threshold:_?(0<#<1&)|Automatic:Automatic
]:=
H5SpecDistribution[
specPts,
{NormalDistribution[#, broadness]&, #/(broadness*Sqrt[2\[Pi]])&},
range,
scaling,
shift,
threshold
]


(* ::Subsubsubsection::Closed:: *)
(*Lorentzian Broadening*)



H5SpecLorentzianBroadening//Clear
H5SpecLorentzianBroadening[
specPts:{{_, _?NumericQ}, ___}, 
broadness_?(NumericQ[#]&&Positive[#]&),
range:{_?NumericQ,_?NumericQ}|Automatic:Automatic,
scaling:Scaled[_?NumericQ]|Automatic:Automatic,
shift:Offset[_?NumericQ, Scaled[_?NumericQ]]|Offset[_?NumericQ]|Automatic:Automatic,
threshold:_?(0<#<1&)|Automatic:Automatic
]:=
H5SpecDistribution[
specPts,
{CauchyDistribution[#, broadness]&, #/(broadness*Sqrt[\[Pi]])&},
range,
scaling,
shift,
threshold
]


(* ::Subsubsubsection::Closed:: *)
(*Plot*)



H5SpecDistributionPlot//Clear
H5SpecDistributionPlot[
dist:_MixtureDistribution,
ops:OptionsPattern[]
]:=
Module[
{
dists=SortBy[Last[dist], First],
distmax=Ordering[First@dist, -1][[1]],
dmpos,
prang,
pdf,
dmval,
dmtarg
},
dmpos=Extract[Last@dist, distmax][[1]];
dmtarg=Extract[First@dist, distmax];
prang={dists[[1, 1]], dists[[-1, 1]]}+10*{-dists[[1, 2]], dists[[-1, 2]]};
dmpos=Extract[Last@dist, Ordering[First@dist, -1]][[1]];
pdf=PDF[dist];
dmval=Quiet[pdf[dmpos], General::munfl];
Quiet[
Plot[dmtarg/dmval pdf[\[Omega]], {\[Omega], prang[[1]], prang[[2]]}, ops, 
Axes->{True, False},
 PlotRange->All,
PlotStyle->Red
],
General::munfl
]
];
H5SpecDistributionPlot[
specPts:{{_, _?NumericQ}, ___},
distFuncs:{_Function|_Symbol, _Function|_Symbol}, 
range:{_?NumericQ,_?NumericQ}|Automatic:Automatic,
scaling:Scaled[_?NumericQ]|Automatic:Automatic,
shift:_?NumericQ|Automatic:Automatic,
threshold:_?(0<#<1&)|Automatic:Automatic,
ops:OptionsPattern[]
]:=
H5SpecDistributionPlot[
H5SpecDistribution[specPts, distFuncs, range, scaling, shift, threshold], 
ops
]


(* ::Subsubsubsection::Closed:: *)
(*Gaussian Broadened Spectrum*)



H5SpecGaussianBroadenedSpectrum//Clear
H5SpecGaussianBroadenedSpectrum[
specPts:{{_, _?NumericQ}, ___}, 
broadness_?(NumericQ[#]&&Positive[#]&),
range:{_?NumericQ,_?NumericQ}|Automatic:Automatic,
scaling:Scaled[_?NumericQ]|Automatic:Automatic,
shift:Offset[_?NumericQ, Scaled[_?NumericQ]]|Offset[_?NumericQ]|Automatic:Automatic,
threshold:_?(0<#<1&)|Automatic:Automatic,
ops:OptionsPattern[]
]:=
H5SpecDistributionPlot[
H5SpecGaussianBroadening[specPts, broadness, range, scaling, shift, threshold], 
ops
]


(* ::Subsubsubsection::Closed:: *)
(*Lorentzian Broadened Spectrum*)



H5SpecLorentzianBroadenedSpectrum//Clear
H5SpecLorentzianBroadenedSpectrum[
specPts:{{_, _?NumericQ}, ___}, 
broadness_?(NumericQ[#]&&Positive[#]&),
range:{_?NumericQ,_?NumericQ}|Automatic:Automatic,
scaling:Scaled[_?NumericQ]|Automatic:Automatic,
shift:Offset[_?NumericQ, Scaled[_?NumericQ]]|Offset[_?NumericQ]|Automatic:Automatic,
threshold:_?(0<#<1&)|Automatic:Automatic,
ops:OptionsPattern[]
]:=
H5SpecDistributionPlot[
H5SpecLorentzianBroadening[specPts, broadness, range, scaling, shift, threshold], 
ops
]


(* ::Subsection:: *)
(*State Assignment Things*)



(* ::Subsubsection::Closed:: *)
(*Common*)



$iH5FormatStatePercentTableRelativeIntensities=True;


iH5CalculateStatePercents[vecs_]:=
100*
Round[
Power[
vecs,
2
], 
.05
];


iH5FormatStatePercentPlot[vecs_]:=
MatrixPlot[
iH5CalculateStatePercents@vecs,
PlotRangePadding->None,
ImageMargins->None,
ImagePadding->None
];


iH5FormatStatePercentTable[vecs_, headers_, states_, ops:OptionsPattern[]]:=
Grid[
Prepend[Join[{"\[ScriptF]", "\[ScriptCapitalI]"}, headers]]@
Join[
Round[List/@Prepend[$H5Data[$H5Key, "Frequencies"], 0][[states]], 1],
List/@
If[TrueQ@$iH5FormatStatePercentTableRelativeIntensities,
Map[
If[#<0.0001, ScientificForm[#, 2], Round[#, .01]]&,
100*#/Max[#]
]&,
Map[ScientificForm[#, 2]&]
]@$H5Data[$H5Key, "Intensities"][[states]],
iH5CalculateStatePercents[vecs],
2
],
ops,
Alignment->Left,
Dividers->{{3->Gray}, {2->Gray}},
ItemSize->Full
]//Style[#, ShowStringCharacters->False]&


(* ::Subsubsection::Closed:: *)
(*H2*)



(*H5FormatH2StatePercentTable[states_]:=
iH5FormatStatePercentTable[
$H5Data[$H5Key, "OuterH2StateVectors"][[states]],
Map[
Superscript[#, "H"~Subscript~2]&,Lookup[$H2StateAssignments, $H5Data[$H5Key, "OuterH2States"]]
],
states
]*)


H5FormatH2StatePercentMatrix[states_, saSpec_:All]:=
Normalize@*Total/@
Transpose[
$H5Data[$H5Key, "OuterH2SliceWavefunctionCoefficients"]
][[states, saSpec]];
H5FormatH2StatePercentMatrix2[states_, saSpec_:All]:=
Normalize@*Total@*Abs/@
Transpose[
$H5Data[$H5Key, "OuterH2SliceWavefunctionCoefficients"]
][[states, saSpec]];


H5FormatH2StatePercentTable[states_, saSpec_:All]:=
iH5FormatStatePercentTable[
H5FormatH2StatePercentMatrix[states, saSpec],
Map[
Superscript[#, "H"~Subscript~2]&,Lookup[$H2StateAssignments, $H5Data[$H5Key, "OuterH2States"]]
],
states
]
H5FormatH2StatePercentTable2[states_, saSpec_:All]:=
iH5FormatStatePercentTable[
H5FormatH2StatePercentMatrix2[states, saSpec],
Map[
Superscript[#, "H"~Subscript~2]&,Lookup[$H2StateAssignments, $H5Data[$H5Key, "OuterH2States"]]
],
states
];
H5FormatH2StatePercentPlot[states_, saSpec_:All]:=
iH5FormatStatePercentPlot@
H5FormatH2StatePercentMatrix[states, saSpec];
H5FormatH2StatePercentPlot2[states_, saSpec_:All]:=
iH5FormatStatePercentPlot[
H5FormatH2StatePercentMatrix2[states, saSpec]
];


(* ::Subsubsection::Closed:: *)
(*H+*)



H5FormatSharedProtonStatePercentMatrix[states_, h2Spec_:All]:=
Normalize@*Total/@
Transpose[
$H5Data[$H5Key, "SharedProtonStateCoefficients"]
][[states, h2Spec]];
H5FormatSharedProtonStatePercentMatrix2[states_, h2Spec_:All]:=
Normalize@*Total@*Abs/@
Transpose[
$H5Data[$H5Key, "SharedProtonStateCoefficients"]
][[states, h2Spec]];


H5FormatSharedProtonStatePercentTable[states_, h2Spec_:All]:=
iH5FormatStatePercentTable[
H5FormatSharedProtonStatePercentMatrix[states, h2Spec],
Map[
Superscript[#, "H+"]&,Thread[Ket[Range[$H5Data[$H5Key, "SharedProtonStates"]]]]
],
states
];
H5FormatSharedProtonStatePercentTable2[states_, h2Spec_:All]:=
iH5FormatStatePercentTable[
H5FormatSharedProtonStatePercentMatrix2[states, h2Spec],
Map[
Superscript[#, "H+"]&,Thread[Ket[Range[$H5Data[$H5Key, "SharedProtonStates"]]]]
],
states
];
H5FormatSharedProtonStatePercentPlot[states_, h2Spec_:All]:=
iH5FormatStatePercentPlot@
H5FormatSharedProtonStatePercentMatrix[states, h2Spec];
H5FormatSharedProtonStatePercentPlot2[states_, h2Spec_:All]:=
iH5FormatStatePercentPlot@
H5FormatSharedProtonStatePercentMatrix2[states, h2Spec];


(* ::Subsubsection::Closed:: *)
(*Combo*)



H5FormatStatePercentTable[states_]:=
iH5FormatStatePercentTable[
Join[
H5FormatH2StatePercentMatrix[states, All],
H5FormatSharedProtonStatePercentMatrix[states, All],
2
],
Map[
Superscript[#, "H"~Subscript~2]&,Lookup[$H2StateAssignments, $H5Data[$H5Key, "OuterH2States"]]
]~Join~
Map[
Superscript[#, "H+"]&,Thread[Ket[Range[$H5Data[$H5Key, "SharedProtonStates"]]]]
],
states,
Dividers->{{3, -10}->Gray//Thread, {2->Gray}}
]


H5FormatStatePercentTable2[states_]:=
iH5FormatStatePercentTable[
Join[
H5FormatH2StatePercentMatrix2[states, All],
H5FormatSharedProtonStatePercentMatrix2[states, All],
2
],
Map[
Superscript[#, "H"~Subscript~2]&,Lookup[$H2StateAssignments, $H5Data[$H5Key, "OuterH2States"]]
]~Join~
Map[
Superscript[#, "H+"]&,Thread[Ket[Range[$H5Data[$H5Key, "SharedProtonStates"]]]]
],
states,
Dividers->{{3, -10}->Gray//Thread, {2->Gray}}
]


(* ::Subsubsection::Closed:: *)
(*Plots*)



H5PlotHPH2States[states_]:=
$H5Data[$H5Key, "SharedProtonSliceWavefunctionsUnnormalized"][[All, states]]//
Transpose//Rescale//
Map[
With[{rs=#},
Map[
ListDensityPlot[
Transpose@Partition[#, $H5Data[$H5Key, "SharedProtonPoints"]], 
ColorFunction->"Rainbow", 
PlotRange->All,
DataRange->{{-2.5, 2.5}, {.7, 3.7}},
ColorFunctionScaling->False,
FrameTicks->None
]&,
rs
]
]&
]//Column[Map[Style[Row[#], LineBreakWithin->False]&, #]]&


H5PlotHPH2States3D[states_]:=
$H5Data[$H5Key, "SharedProtonSliceWavefunctionsUnnormalized"][[All, states]]//
Transpose//Rescale//
Map[
With[{rs=#},
Map[
ListPlot3D[
Transpose@Partition[#, $H5Data[$H5Key, "SharedProtonPoints"]], 
ColorFunction->"Rainbow", 
PlotRange->All,
DataRange->{{-2.5, 2.5}, {.7, 3.7}},
ColorFunctionScaling->False
]&,
rs
]
]&
]//Grid


Clear@H5PlotH2HPStates;
H5PlotH2HPStates[states_, hpStates:_:{14*30+6, 15*30+6}]:=
$H5Data[$H5Key, "OuterH2SliceWavefunctions"][[states, hpStates]]//Rescale//
Map[
With[{rs=#},
Map[
ListDensityPlot[
Transpose@Partition[#, $H5Data[$H5Key, "OuterH2Points"]], 
ColorFunction->"Rainbow",
PlotRange->All,
DataRange->{{.25, 1}, {.25, 1}},
ColorFunctionScaling->False,
FrameTicks->None
]&,
rs
]
]&
]//Column[Map[Style[Row[#], LineBreakWithin->False]&, #]]&


Clear@H5PlotH2HPStates3D;
H5PlotH2HPStates3D[states_, hpStates:_:{14*30+6, 15*30+6}]:=
$H5Data[$H5Key, "OuterH2SliceWavefunctions"][[states, hpStates]]//Rescale//
Map[
With[{rs=#},
Map[
ListPlot3D[
Transpose@Partition[#, $H5Data[$H5Key, "OuterH2Points"]], 
ColorFunction->"Rainbow",
PlotRange->All,
DataRange->{{.25, 1}, {.25, 1}},
ColorFunctionScaling->False
]&,
rs
]
]&
]//Grid


End[];


EndPackage[];



